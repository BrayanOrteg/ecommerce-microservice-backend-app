trigger: none
pr: none

parameters:
  - name: profile
    displayName: 'Elige un perfil (prod / dev / stage)'
    type: string
    default: dev
    values:
      - dev
      - stage
      - prod

variables:
  # Azure Service Connection for AKS and other Azure resources
  azureSubscription: 'ecommerce-terraform-sc'
  # Docker Hub Service Connection
  dockerHubServiceConnection: 'ecommerce-docker'
  
  # Environment variables
  RESOURCE_GROUP: 'rg-${{ parameters.profile }}'
  CLUSTER_NAME: 'aks-${{ parameters.profile }}'
  K8S_MANIFEST_DIR: 'k8s'

pool:
  vmImage: 'ubuntu-latest'

stages:
  - stage: Checkout
    displayName: 'Checkout Source Code'
    jobs:
      - job: CheckoutJob
        steps:
          - checkout: self
            displayName: 'Checkout repository'

  - stage: Build
    displayName: 'Build Project'
    jobs:
      - job: BuildJob
        steps:
          - task: Maven@4
            inputs:
              azureSubscription: 'ecommerce-terraform-sc'
              mavenPomFile: 'pom.xml'
              goals: 'clean package'
              options: '-DskipTests'
              publishJUnitResults: false
              javaHomeOption: 'JDKVersion'
              mavenVersionOption: 'Default'
              mavenAuthenticateFeed: false
              effectivePomSkip: false
              sonarQubeRunAnalysis: false

  - stage: SonnarQube
    displayName: 'SonnarQube Cloud'
    jobs:
      - job: SonnarJob
        steps:
        - task: SonarCloudPrepare@3
          inputs:
            SonarQube: 'ecommerce-sonar-qube'
            organization: 'brayan-organization'
            scannerMode: 'other'
            extraProperties: |
              # Additional properties that will be passed to the scanner,
              # Put one key=value per line, example:
              # sonar.exclusions=**/*.bin
              sonar.projectKey=brayan-organization_First-pipeline
              sonar.projectName=First pipeline

  - stage: UnitAndIntegrationTests
    displayName: 'Run Unit and Integration Tests'
    jobs:
      - job: TestJob
        steps:
          - task: Maven@4
            inputs:
              azureSubscription: 'ecommerce-terraform-sc'
              mavenPomFile: 'pom.xml'
              goals: 'clean package'
              options: '-DskipTests=false'
              publishJUnitResults: false
              javaHomeOption: 'JDKVersion'
              mavenVersionOption: 'Default'
              mavenAuthenticateFeed: false
              effectivePomSkip: false
              sonarQubeRunAnalysis: false

  - stage: BuildAndPushDockerImages
    displayName: 'Build and Push Docker Images'
    jobs:
      - job: DockerJob
        steps:
          - task: Maven@4
            inputs:
              azureSubscription: 'ecommerce-terraform-sc'
              mavenPomFile: 'pom.xml'
              goals: 'clean package'
              options: '-DskipTests'
              publishJUnitResults: false
              javaHomeOption: 'JDKVersion'
              mavenVersionOption: 'Default'
              mavenAuthenticateFeed: false
              effectivePomSkip: false
              sonarQubeRunAnalysis: false
          - task: Docker@2
            displayName: 'Login to Docker Hub'
            inputs:
              containerRegistry: $(dockerHubServiceConnection)
              command: 'login'
          - script: |
              docker compose -f compose.yml build
              docker compose -f compose.yml push
            displayName: 'Build and Push Docker Images with Docker Compose'
          - task: Docker@2
            displayName: 'Logout from Docker Hub'
            inputs:
              containerRegistry: $(dockerHubServiceConnection)
              command: 'logout'
            condition: succeededOrFailed()

  - stage: DeployToAKS
    displayName: 'Configure kubectl and deploy to AKS'
    jobs:
      - job: DeployJob
        steps:
          - task: AzureCLI@2
            inputs:
              azureSubscription: 'ecommerce-terraform-sc'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: 'az aks get-credentials --resource-group $(RESOURCE_GROUP) --name $(CLUSTER_NAME) --overwrite-existing'

          - task: KubernetesManifest@1
            displayName: 'Apply Zipkin Manifest'
            inputs:
              action: 'deploy'
              connectionType: 'azureResourceManager'
              azureSubscriptionConnection: 'ecommerce-terraform-sc'
              azureResourceGroup: '$(RESOURCE_GROUP)'
              kubernetesCluster: '$(CLUSTER_NAME)'
              namespace: 'default'
              manifests: '$(K8S_MANIFEST_DIR)/zipkin.yaml'
          - script: |
              echo "Waiting for Zipkin to be healthy..."
              # Asume que zipkin.yaml crea un Deployment llamado 'zipkin'
              kubectl rollout status deployment/zipkin -n default --timeout=5m
              # O si es un pod o tiene otra etiqueta específica, puedes usar:
              # kubectl wait --for=condition=Ready pod -l app=zipkin-app -n default --timeout=5m
            displayName: 'Wait for Zipkin to be Healthy'
            condition: succeeded()

          - task: KubernetesManifest@1
            displayName: 'Apply Service Discovery Manifest'
            inputs:
              action: 'deploy'
              connectionType: 'azureResourceManager'
              azureSubscriptionConnection: 'ecommerce-terraform-sc'
              azureResourceGroup: '$(RESOURCE_GROUP)'
              kubernetesCluster: '$(CLUSTER_NAME)'
              namespace: 'default'
              manifests: '$(K8S_MANIFEST_DIR)/service-discovery.yaml'
          - script: |
              echo "Waiting for Service Discovery to be healthy..."
              # Asume que service-discovery.yaml crea un Deployment llamado 'service-discovery'
              kubectl rollout status deployment/service-discovery -n default --timeout=5m
              # O si es un pod o tiene otra etiqueta específica:
              # kubectl wait --for=condition=Ready pod -l app=service-discovery-app -n default --timeout=5m
            displayName: 'Wait for Service Discovery to be Healthy'
            condition: succeeded()

          - task: KubernetesManifest@1
            displayName: 'Apply Cloud Config Manifest'
            inputs:
              action: 'deploy'
              connectionType: 'azureResourceManager'
              azureSubscriptionConnection: 'ecommerce-terraform-sc'
              azureResourceGroup: '$(RESOURCE_GROUP)'
              kubernetesCluster: '$(CLUSTER_NAME)'
              namespace: 'default'
              manifests: '$(K8S_MANIFEST_DIR)/cloud-config.yaml'
          - script: |
              echo "Waiting for Cloud Config to be healthy..."
              # Asume que cloud-config.yaml crea un Deployment llamado 'cloud-config'
              kubectl rollout status deployment/cloud-config -n default --timeout=5m
              # O si es un pod o tiene otra etiqueta específica:
              # kubectl wait --for=condition=Ready pod -l app=cloud-config-app -n default --timeout=5m
            displayName: 'Wait for Cloud Config to be Healthy'
            condition: succeeded()